#include <stdio.h>
#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/dma.h"
#include "hardware/clocks.h" // Required for clock_get_hz

// This header is generated by CMake from our .pio file
#include "pd_sniffer.pio.h" 

// --- Configuration (FROM YOUR SCHEMATIC) ---
// The GPIO pin connected to the CC line comparator output
#define CC_PIN 28

// System clock speed (120 MHz)
// Note: We use clock_get_hz(clk_sys) for accuracy.
// The SYS_CLK_KHZ macro is defined in the SDK.

// USB-PD BMC base clock rate (300 kHz)
#define PD_CLK_HZ 300000

// Oversampling rate (8x)
#define OVERSAMPLE_RATE 8
#define SAMPLE_FREQ (PD_CLK_HZ * OVERSAMPLE_RATE) // 2.4 MHz

// DMA buffer size (in 32-bit words)
#define CAPTURE_BUF_SIZE (1024 * 4)

// --- Globals ---
PIO pio = pio0;
uint sm;
uint dma_chan;

// We make the buffer "dma_safe" by aligning it and placing it in a
// specific RAM section. This prevents bus contention.
__attribute__ ((aligned(4)))
uint32_t capture_buf[CAPTURE_BUF_SIZE];


// --- Decoder State and Data Structures ---

// 4b/5b symbol decoding table (maps 5-bit code to 4-bit nibble)
const uint8_t DECODE_4B5B[32] = {
    0xFF, 0x01, 0xFF, 0xFF, 0x0A, 0x0B, 0xFF, 0x07, // 00xxx
    0xFF, 0x09, 0x08, 0xFF, 0x0D, 0x0C, 0x0E, 0x0F, // 01xxx
    0xFF, 0x02, 0x03, 0xFF, 0x04, 0x05, 0x06, 0xFF, // 10xxx
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF  // 11xxx
};

// K-Codes for control signals
#define K_SYNC1 0b11000
#define K_SYNC2 0b10001
#define K_RST1  0b00111
#define K_RST2  0b11001
#define K_EOP   0b01101

// Decoder state machine
typedef enum {
    STATE_IDLE,
    STATE_PREAMBLE,
    STATE_SOP,
    STATE_HEADER,
    STATE_DATA,
    STATE_CRC,
    STATE_EOP
} decoder_state_t;

// Structure to hold our decoded packet
typedef struct {
    uint16_t header;
    uint32_t data[7]; // Max 7 data objects
    uint32_t crc;
    uint8_t num_data_objs;
    bool valid;
} pd_packet_t;


// --- BMC Decoding Logic ---

// Forward declaration for the packet decoder state machine
void process_decoded_bit(bool bit_val);

// Processes a block of 32 raw samples from the DMA buffer
void bmc_decoder_feed(uint32_t sample_word) {
    // State for the BMC decoder
    static uint8_t last_level = 0;
    static uint32_t run_length = 0;
    static uint32_t last_run_length = 0;
    static bool initialized = false;

    // Initialize decoder on first run
    if (!initialized) {
        last_level = sample_word & 1;
        initialized = true;
    }

    for (int i = 0; i < 32; i++) {
        uint8_t current_level = (sample_word >> i) & 1;

        if (current_level != last_level) {
            // Transition detected. Analyze the length of the completed run.
            // T (bit period) = 8 samples.
            // Tolerance window for T/2 (4 samples) and T (8 samples).
            if (run_length >= 6 && run_length <= 10) { // Full-bit run
                // A full-width pulse between transitions means a '0' was sent.
                process_decoded_bit(0);
                last_run_length = 0; // Reset history
            } else if (run_length >= 3 && run_length <= 5) { // Half-bit run
                // A half-width pulse. Could be first or second part of a '1'.
                if (last_run_length >= 3 && last_run_length <= 5) {
                    // Second consecutive half-width pulse. A '1' was sent.
                    process_decoded_bit(1);
                    last_run_length = 0; // Reset history
                } else {
                    // First half-width pulse. Store it and wait for the next.
                    last_run_length = run_length;
                }
            } else {
                // Invalid run length -> noise or sync loss. Reset history.
                last_run_length = 0;
            }

            run_length = 1; // Reset for the next run
            last_level = current_level;
        } else {
            run_length++;
        }
    }
}


// --- 4b/5b and Packet Decoding Logic ---

// This is our main state machine for decoding the packet structure
void process_decoded_bit(bool bit_val) {
    // State machine variables
    static decoder_state_t state = STATE_IDLE;
    static uint64_t shift_reg = 0;
    static int idle_bit_count = 0;
    static int packet_bit_count = 0;
    static pd_packet_t current_packet;
    static int data_obj_count = 0;

    // A bit '1' resets our idle detection
    if (bit_val) {
        idle_bit_count = 0;
    } else {
        idle_bit_count++;
    }

    // After ~1.2ms of idle (no transitions), reset to a known state
    if (idle_bit_count > (PD_CLK_HZ / 1000) * 1.2) {
        state = STATE_IDLE;
    }

    // Shift the new bit into our shift register
    shift_reg = (shift_reg << 1) | bit_val;

    if (state != STATE_IDLE) {
        packet_bit_count++;
    }

    switch (state) {
        case STATE_IDLE:
            // Look for the 64-bit preamble
            if ((shift_reg & 0xFFFFFFFFFFFFFFFF) == 0xAAAAAAAAAAAAAAA9) {
                state = STATE_PREAMBLE;
                packet_bit_count = 0;
            }
            break;

        case STATE_PREAMBLE:
            // Preamble is consumed, now look for SOP
            // SOP is composed of 4 K-Codes
            if ((shift_reg & 0xFFFFF) == ((uint32_t)K_SYNC1 << 15 | (uint32_t)K_SYNC1 << 10 | (uint32_t)K_SYNC1 << 5 | K_SYNC2)) {
                state = STATE_SOP;
                packet_bit_count = 0;
                current_packet.valid = false;
                data_obj_count = 0;
            }
            break;

        case STATE_SOP:
            // SOP is consumed, now we're at the start of the message
            state = STATE_HEADER;
            packet_bit_count = 0;
            break;

        case STATE_HEADER:
            // Every 5 bits, decode a symbol
            if (packet_bit_count > 0 && (packet_bit_count % 5 == 0)) {
                uint8_t symbol = (shift_reg >> (packet_bit_count - 5)) & 0x1F;
                uint8_t nibble = DECODE_4B5B[symbol];

                if (nibble == 0xFF) { // Invalid symbol
                    state = STATE_IDLE;
                    break;
                }

                current_packet.header = (current_packet.header << 4) | nibble;

                // After 4 nibbles (20 bits), we have the full header
                if (packet_bit_count == 20) {
                    current_packet.num_data_objs = (current_packet.header >> 12) & 0x7;
                    if (current_packet.num_data_objs == 0) {
                        state = STATE_CRC;
                    } else {
                        state = STATE_DATA;
                    }
                    data_obj_count = 0;
                    packet_bit_count = 0;
                }
            }
            break;

        case STATE_DATA:
            // Similar to header, but for 32-bit data objects
            if (packet_bit_count > 0 && (packet_bit_count % 5 == 0)) {
                uint8_t symbol = (shift_reg >> (packet_bit_count - 5)) & 0x1F;
                uint8_t nibble = DECODE_4B5B[symbol];

                if (nibble == 0xFF) {
                    state = STATE_IDLE;
                    break;
                }

                current_packet.data[data_obj_count] = (current_packet.data[data_obj_count] << 4) | nibble;

                // After 8 nibbles (40 bits), we have a full data object
                if (packet_bit_count == 40) {
                    data_obj_count++;
                    if (data_obj_count == current_packet.num_data_objs) {
                        state = STATE_CRC;
                    }
                    packet_bit_count = 0;
                }
            }
            break;

        case STATE_CRC:
            // Decode the 32-bit CRC
            if (packet_bit_count > 0 && (packet_bit_count % 5 == 0)) {
                uint8_t symbol = (shift_reg >> (packet_bit_count - 5)) & 0x1F;
                uint8_t nibble = DECODE_4B5B[symbol];

                if (nibble == 0xFF) {
                    state = STATE_IDLE;
                    break;
                }

                current_packet.crc = (current_packet.crc << 4) | nibble;

                if (packet_bit_count == 40) {
                    state = STATE_EOP;
                    packet_bit_count = 0;
                }
            }
            break;

        case STATE_EOP:
            // Look for the EOP K-Code
            if ((shift_reg & 0x1F) == K_EOP) {
                current_packet.valid = true;

                // --- Print Decoded Packet ---
                printf("--- PD Packet ---\n");
                printf("Header: 0x%04x\n", current_packet.header);
                printf("Data Objs: %d\n", current_packet.num_data_objs);
                for (int i = 0; i < current_packet.num_data_objs; i++) {
                    printf("  Data[%d]: 0x%08x\n", i, current_packet.data[i]);
                }
                printf("CRC: 0x%08x\n", current_packet.crc);
                printf("-----------------\n\n");

            }
            // In either case, we're done with this packet
            state = STATE_IDLE;
            break;
    }
}


// Main sniffer initialization
void sniffer_init() {
    // --- GPIO Setup ---
    // Initialize the CC_PIN (GP28) for PIO input
    // This is the output from your LMV358 comparator
    pio_gpio_init(pio, CC_PIN);
    // No pulls are needed; the comparator is driving this pin.
    
    // --- PIO Setup ---
    // Load the PIO program
    uint offset = pio_add_program(pio, &pd_sampler_program);

    // Find a free state machine
    sm = pio_claim_unused_sm(pio, true);

    // Calculate the clock divider for our sample rate
    float div = (float)clock_get_hz(clk_sys) / (float)SAMPLE_FREQ;

    // Initialize the PIO state machine
    pd_sampler_program_init(pio, sm, offset, CC_PIN, div);
    
    // --- DMA Setup ---
    // Get a free DMA channel
    dma_chan = dma_claim_unused_channel(true);
    dma_channel_config c = dma_channel_get_default_config(dma_chan);

    // Configure DMA
    channel_config_set_transfer_data_size(&c, DMA_SIZE_32); // 32-bit transfers
    channel_config_set_read_increment(&c, false);           // Read from same PIO FIFO address
    channel_config_set_write_increment(&c, true);           // Write to sequential buffer addresses
    channel_config_set_dreq(&c, pio_get_dreq(pio, sm, false)); // Triggered by PIO RX
    
    // Configure the DMA to loop back to the start of the buffer
    // when it reaches the end.
    channel_config_set_ring(&c, true, 14); // Ring write buffer (1<<14 = 16384 bytes = 4096 words)

    // Start DMA
    dma_channel_configure(
        dma_chan,
        &c,
        capture_buf,           // Write address (start of our buffer)
        &pio->rxf[sm],         // Read address (PIO RX FIFO)
        CAPTURE_BUF_SIZE,      // Number of transfers
        true                   // Start immediately
    );

    // --- Start ---
    // Start the PIO state machine
    pio_sm_set_enabled(pio, sm, true);
}

// Main loop to process and print the data
void sniffer_loop() {
    static uint32_t read_index = 0;

    // Get the DMA's current write position (as an index)
    uint32_t dma_write_index = dma_hw->ch[dma_chan].write_addr / 4;
    dma_write_index = (dma_write_index - ((uint32_t)capture_buf / 4)) % CAPTURE_BUF_SIZE;


    // Process all new data in the buffer
    while (read_index != dma_write_index) {
        
        // Feed the raw data to our BMC decoder
        bmc_decoder_feed(capture_buf[read_index]);
        
        // Move the read index forward, wrapping around
        read_index = (read_index + 1) % CAPTURE_BUF_SIZE;
    }

    // A small sleep prevents the USB serial from being
    // overwhelmed if there's no data.
    sleep_us(10); 
}

int main() {
    // Set system clock to 120 MHz
    set_sys_clock_khz(SYS_CLK_KHZ, true);

    // Initialize USB serial
    stdio_init_all();
    
    // Optional: wait for USB connection
    // while (!stdio_usb_connected()) { sleep_ms(100); }
    
    printf("RP2040 PD Sniffer Initializing...\n");
    printf("Clock: %lu Hz\n", clock_get_hz(clk_sys));
    printf("Sample Freq: %d Hz\n", SAMPLE_FREQ);
    printf("Capture Pin: GP%d\n", CC_PIN);

    // Initialize the PIO and DMA
    sniffer_init();
    
    printf("Sniffer running!\n");

    // --- Main Loop ---
    while (true) {
        sniffer_loop();
    }
}
